import { 测量字符串 } from "../工具.js";
import { 常量, 接口 } from "../运行时/易次元.js";
import { 承诺 } from "../运行时/网络/承诺.js";

interface 辅助阅读器构造参数 {
    内容: 字符串;
    背景图资源标识: 资源标识;
    背景图水平翻转?: 是否;
    背景图垂直翻转?: 是否;
    阅读器宽度: 数值 | 最大填充;
    阅读器高度: 数值 | 最大填充;
    阅读器水平对齐方式?: 水平对齐方式;
    阅读器垂直对齐方式?: 垂直对齐方式;
}

export class 辅助阅读器类 {
    #内容: 字符串;
    #背景资源标识: 资源标识;
    #背景图水平翻转: 是否;
    #背景图垂直翻转: 是否;
    #阅读器宽度: 数值 | 最大填充;
    #阅读器高度: 数值 | 最大填充;
    #阅读器水平对齐方式?: 水平对齐方式;
    #阅读器垂直对齐方式?: 垂直对齐方式;

    constructor(构造参数: 辅助阅读器构造参数) {
        this.#内容 = 构造参数.内容;
        this.#背景资源标识 = 构造参数.背景图资源标识;
        this.#背景图水平翻转 = 构造参数.背景图水平翻转 ?? 否;
        this.#背景图垂直翻转 = 构造参数.背景图垂直翻转 ?? 否;
        this.#阅读器宽度 = 构造参数.阅读器宽度;
        this.#阅读器高度 = 构造参数.阅读器高度;
        this.#阅读器水平对齐方式 = 构造参数.阅读器水平对齐方式;
        this.#阅读器垂直对齐方式 = 构造参数.阅读器垂直对齐方式;
    }

    async 查看() {
        await 接口.创建图片("辅助阅读_背景", {
            层级索引: 200,
            资源标识: this.#背景资源标识,
            位置: { 横: 640, 纵: 360 },
            锚点: { 横: 50, 纵: 50 },
            动态缩放模式: 最大填充,
            水平翻转: this.#背景图水平翻转,
            垂直翻转: this.#背景图垂直翻转,
            是否可见: 否,
        });

        const 画布大小 = await 接口.获取画布大小();
        await 接口.创建图层("辅助阅读_图层", {
            层级索引: 210,
            裁剪模式: 是,
            裁剪区域: 画布大小,
            是否可见: 否,
        });

        // rome-ignore format: 关闭
        const 阅读器大小 = {
            宽: this.#阅读器宽度 === 最大填充 ? 画布大小.宽                    // 最大填充 时，阅读器宽度等于画布宽度
              : this.#阅读器宽度 < 1          ? 画布大小.宽 * this.#阅读器宽度 //      0~1 时，阅读器宽度等于画布宽度乘以该值（百分比值）
              : this.#阅读器宽度,                                              //   大于 1 时，阅读器宽度等于该值（像素值）
            高: this.#阅读器高度 === 最大填充 ? 画布大小.高                    // 最大填充 时，阅读器高度等于画布高度
              : this.#阅读器高度 < 1          ? 画布大小.高 * this.#阅读器高度 //      0~1 时，阅读器高度等于画布高度乘以该值（百分比值）
              : this.#阅读器高度,                                              //   大于 1 时，阅读器高度等于该值（像素值）
        };

        const 水平靠左 = this.#阅读器水平对齐方式 === 水平对齐方式.靠左;
        const 水平居中 = this.#阅读器水平对齐方式 === 水平对齐方式.居中;
        const 垂直靠上 = this.#阅读器垂直对齐方式 === 垂直对齐方式.靠上;
        const 垂直居中 = this.#阅读器垂直对齐方式 === 垂直对齐方式.居中;
        // rome-ignore format: 关闭
        const 阅读器位置 = {
            横: 水平靠左 ? 0                                        // 靠左 时，阅读器横坐标为 0
              : 水平居中 ? (画布大小.宽 - 阅读器大小.宽) / 2        // 居中 时，阅读器横坐标为画布宽度减去阅读器宽度后的一半
              : 画布大小.宽 - 阅读器大小.宽,                        // 靠右 时，阅读器横坐标为画布宽度减去阅读器宽度
            纵: 垂直靠上 ? 画布大小.高 - 阅读器大小.高              // 靠上 时，阅读器纵坐标为画布高度减去阅读器高度
              : 垂直居中 ? (画布大小.高 - 阅读器大小.高) / 2        // 居中 时，阅读器纵坐标为画布高度减去阅读器高度后的一半
              : 0,                                                  // 靠下 时，阅读器纵坐标为 0
        };

        this.#内容.split("\n").map((行, 索引) => {
            console.log({ 行, 测量结果: 测量字符串(行) });
            return [行, 测量字符串(行)];
        });

        await 接口.创建滚动视图("辅助阅读_滚动视图", {
            所属图层: "辅助阅读_图层",
            位置: 阅读器位置,
            视图大小: 阅读器大小,
            内容大小: { 宽: 阅读器大小.宽, 高: 720 },
            是否水平滚动: 否,
            是否垂直滚动: 是,
        });

        await 接口.添加事件侦听器("辅助阅读_背景", 常量.事件类型.点触结束, () => {
            接口.隐藏对象("辅助阅读_图层", { 时长: 300 });
            接口.隐藏对象("辅助阅读_背景", { 时长: 300 });
        });

        await 承诺.全部([接口.显示对象("辅助阅读_图层", { 时长: 300 }), 接口.显示对象("辅助阅读_背景", { 时长: 300 })]);
    }
}
