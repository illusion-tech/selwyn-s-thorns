import type { 字符串, 数值, 是否, 资源标识 } from "../运行时/全局常量.ts";
import { 否, 垂直对齐方式, 是, 最大填充, 水平对齐方式 } from "../运行时/全局常量.ts";
import { 测量字符串 } from "../工具.ts";
import { 常量, 接口 } from "../运行时/易次元.ts";
import { 承诺 } from "../运行时/网络/承诺.ts";

interface 辅助阅读器构造参数 {
    文本内容: 字符串;
    文本字体?: { 名称: 字符串; 字号: 数值; 颜色: 字符串 };
    文本行间距?: 数值;
    文本水平对齐方式?: 水平对齐方式;
    文本垂直对齐方式?: 垂直对齐方式;
    背景图资源标识: 资源标识;
    背景图水平翻转?: 是否;
    背景图垂直翻转?: 是否;
    容器宽度: 数值 | 最大填充;
    容器高度: 数值 | 最大填充;
    容器水平对齐方式?: 水平对齐方式;
    容器垂直对齐方式?: 垂直对齐方式;
    容器内边距?: { 上: 数值; 右: 数值; 下: 数值; 左: 数值 };
}

export class 辅助阅读器类 {
    #文本内容: 字符串;
    #背景资源标识: 资源标识;
    #背景图水平翻转: 是否;
    #背景图垂直翻转: 是否;
    #容器宽度: 数值 | 最大填充;
    #容器高度: 数值 | 最大填充;
    #容器水平对齐方式?: 水平对齐方式;
    #容器垂直对齐方式?: 垂直对齐方式;
    #容器内边距: { 上: 数值; 右: 数值; 下: 数值; 左: 数值 };
    #文本字体: { 名称: 字符串; 字号: 数值; 颜色: 字符串 };
    #文本行高: 数值;
    #文本对齐方式: { 水平: 水平对齐方式; 垂直: 垂直对齐方式 };

    constructor(构造参数: 辅助阅读器构造参数) {
        this.#文本内容 = 构造参数.文本内容;
        this.#背景资源标识 = 构造参数.背景图资源标识;
        this.#背景图水平翻转 = 构造参数.背景图水平翻转 ?? 否;
        this.#背景图垂直翻转 = 构造参数.背景图垂直翻转 ?? 否;
        this.#容器宽度 = 构造参数.容器宽度;
        this.#容器高度 = 构造参数.容器高度;
        this.#容器水平对齐方式 = 构造参数.容器水平对齐方式;
        this.#容器垂直对齐方式 = 构造参数.容器垂直对齐方式;
        this.#容器内边距 = 构造参数.容器内边距 ?? { 上: 0, 右: 0, 下: 0, 左: 0 };
        this.#文本字体 = 构造参数.文本字体 ?? { 名称: "方正楷体", 字号: 30, 颜色: "#000000" };
        const 文本间距 = 构造参数.文本行间距 ?? 1.3;
        // rome-ignore format: 关闭
        this.#文本行高 = 文本间距 < 1 ? this.#文本字体.字号
                       : 文本间距 < 2 ? this.#文本字体.字号 * 文本间距
                       : 文本间距 + this.#文本字体.字号;
        this.#文本对齐方式 = {
            水平: 构造参数.文本水平对齐方式 ?? 水平对齐方式.靠左,
            垂直: 构造参数.文本垂直对齐方式 ?? 垂直对齐方式.靠上,
        };
    }

    async 查看() {
        await 接口.创建图片("辅助阅读_背景", {
            层级索引: 200,
            资源标识: this.#背景资源标识,
            位置: { 横: 640, 纵: 360 },
            锚点: { 横: 50, 纵: 50 },
            动态缩放模式: 常量.动态缩放模式.覆盖,
            水平翻转: this.#背景图水平翻转,
            垂直翻转: this.#背景图垂直翻转,
            是否可见: 否,
        });

        const 画布大小 = await 接口.获取画布大小();
        await 接口.创建图层("辅助阅读_图层", {
            层级索引: 210,
            裁剪模式: 是,
            裁剪区域: 画布大小,
            是否可见: 否,
        });

        // rome-ignore format: 关闭
        const 阅读器大小 = {
            宽: this.#容器宽度 === 最大填充 ? 画布大小.宽                  // 最大填充 时，阅读器宽度等于画布宽度
              : this.#容器宽度 < 1          ? 画布大小.宽 * this.#容器宽度 //      0~1 时，阅读器宽度等于画布宽度乘以该值（百分比值）
              : this.#容器宽度,                                            //   大于 1 时，阅读器宽度等于该值（像素值）
            高: this.#容器高度 === 最大填充 ? 画布大小.高                  // 最大填充 时，阅读器高度等于画布高度
              : this.#容器高度 < 1          ? 画布大小.高 * this.#容器高度 //      0~1 时，阅读器高度等于画布高度乘以该值（百分比值）
              : this.#容器高度,                                            //   大于 1 时，阅读器高度等于该值（像素值）
        };

        const 水平靠左 = this.#容器水平对齐方式 === 水平对齐方式.靠左;
        const 水平居中 = this.#容器水平对齐方式 === 水平对齐方式.居中;
        const 垂直靠上 = this.#容器垂直对齐方式 === 垂直对齐方式.靠上;
        const 垂直居中 = this.#容器垂直对齐方式 === 垂直对齐方式.居中;
        // rome-ignore format: 关闭
        const 阅读器位置 = {
            横: 水平靠左 ? 0                                        // 靠左 时，阅读器横坐标为 0
              : 水平居中 ? (画布大小.宽 - 阅读器大小.宽) / 2        // 居中 时，阅读器横坐标为画布宽度减去阅读器宽度后的一半
              : 画布大小.宽 - 阅读器大小.宽,                        // 靠右 时，阅读器横坐标为画布宽度减去阅读器宽度
            纵: 垂直靠上 ? 画布大小.高 - 阅读器大小.高              // 靠上 时，阅读器纵坐标为画布高度减去阅读器高度
              : 垂直居中 ? (画布大小.高 - 阅读器大小.高) / 2        // 居中 时，阅读器纵坐标为画布高度减去阅读器高度后的一半
              : 0,                                                  // 靠下 时，阅读器纵坐标为 0
        };

        await 接口.创建文本样式("阅读器文本样式", {
            字体: this.#文本字体.名称,
            字号: this.#文本字体.字号,
            颜色: this.#文本字体.颜色,
            描边宽度: 0,
            阴影颜色: "#000000",
            阴影偏移: { 水平: 1, 垂直: 1 },
        });

        const 行宽 = 阅读器大小.宽 - this.#容器内边距.左 - this.#容器内边距.右;
        const 行高 = this.#文本行高;

        const 内容高度 = this.#文本内容.split("\n").reduce((高, 行) => {
            const 测量结果 = 测量字符串(行, `${this.#文本字体.字号}px ${this.#文本字体.名称}`);

            const 行数 = Math.ceil(
                测量结果.宽度 <= 行宽 - this.#文本字体.字号 ? 1 : 测量结果.宽度 / (行宽 - this.#文本字体.字号),
            );

            console.log({ 行, 测量结果, 行数 });
            return 高 + 行高 * 行数;
        }, 0);

        const 阅读器滚动内容宽度 = 阅读器大小.宽;
        const 阅读器滚动内容高度 = 内容高度 > 阅读器大小.高 ? 内容高度 : 阅读器大小.高;
        await 接口.创建滚动视图("辅助阅读_滚动视图", {
            所属图层: "辅助阅读_图层",
            位置: 阅读器位置,
            视图大小: 阅读器大小,
            内容大小: { 宽: 阅读器滚动内容宽度, 高: 阅读器滚动内容高度 },
            是否水平滚动: 否,
            是否垂直滚动: 是,
        });

        await 接口.创建文本("辅助阅读_文本", {
            所属图层: "辅助阅读_滚动视图",
            文本样式: "阅读器文本样式",
            文本内容: this.#文本内容,
            位置: { 横: this.#容器内边距.左, 纵: 阅读器滚动内容高度 - this.#容器内边距.上 - 内容高度 },
            文本框大小: { 宽: 行宽, 高: 内容高度 },
            水平对齐方式: this.#文本对齐方式.水平,
            垂直对齐方式: this.#文本对齐方式.垂直,
        });

        await 接口.添加事件侦听器("辅助阅读_图层", 常量.事件类型.点触结束, () => {
            接口.播放音频("点击音效", { 资源标识: "$51624", 音量: 100 });
            接口.隐藏对象("辅助阅读_图层", { 时长: 300 });
            接口.隐藏对象("辅助阅读_背景", { 时长: 300 });
        });

        await 承诺.全部([接口.显示对象("辅助阅读_图层", { 时长: 300 }), 接口.显示对象("辅助阅读_背景", { 时长: 300 })]);
    }
}
